<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹å‹¢æ§åˆ¶ç²’å­ç³»çµ±</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #webcam {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            height: 225px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 2;
            transform: scaleX(-1); /* é¡åƒ */
        }

        #controlPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            z-index: 3;
            width: 320px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 25px;
            z-index: 3;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        h1 {
            font-size: 24px;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #ff7e5f, #feb47b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        h2 {
            font-size: 16px;
            margin: 15px 0 10px 0;
            color: #feb47b;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button.active {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            box-shadow: 0 0 15px rgba(245, 87, 108, 0.5);
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }

        .status {
            display: flex;
            align-items: center;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 14px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            background: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }

        .status-indicator.inactive {
            background: #f44336;
            box-shadow: 0 0 10px #f44336;
        }

        .hand-status {
            margin-top: 10px;
            font-size: 14px;
            color: #feb47b;
            text-align: center;
            padding: 8px;
            background: rgba(254, 180, 123, 0.1);
            border-radius: 8px;
        }

        #gestureInfo {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.4;
        }

        .gesture-icon {
            font-size: 24px;
            margin-right: 10px;
        }

        .particle-count {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            #controlPanel {
                width: 280px;
                padding: 15px;
            }
            
            #webcam {
                width: 200px;
                height: 150px;
            }
            
            .button-group {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas3d"></canvas>
        <video id="webcam" autoplay playsinline></video>
        
        <div id="controlPanel">
            <h1>3D æ‰‹å‹¢æ§åˆ¶ç²’å­ç³»çµ±</h1>
            
            <div class="control-group">
                <h2>ç²’å­å½¢ç‹€æ¨¡æ¿</h2>
                <div class="button-group">
                    <button id="shapeHeart" class="active">â¤ï¸ æ„›å¿ƒ</button>
                    <button id="shapeFlower">ğŸŒ¸ èŠ±æœµ</button>
                    <button id="shapeSaturn">ğŸª åœŸæ˜Ÿ</button>
                    <button id="shapeFirework">ğŸ† ç…™ç«</button>
                    <button id="shapeSphere">ğŸ”µ çƒé«”</button>
                    <button id="shapeCube">â¬› ç«‹æ–¹é«”</button>
                    <button id="shapeSpiral">ğŸŒ€ èºæ—‹</button>
                    <button id="shapeWave">ğŸŒŠ æ³¢æµª</button>
                    <button id="shapeRandom">ğŸ² éš¨æ©Ÿ</button>
                </div>
            </div>
            
            <div class="control-group">
                <h2>é¡è‰²æ§åˆ¶</h2>
                <div class="slider-label">
                    <span>ç²’å­é¡è‰²</span>
                    <span id="colorValue">#FF7E5F</span>
                </div>
                <input type="color" id="colorPicker" value="#FF7E5F">
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>è‰²å½©é®®è±”åº¦</span>
                        <span id="saturationValue">100%</span>
                    </div>
                    <input type="range" id="saturationSlider" min="0" max="200" value="100">
                </div>
            </div>
            
            <div class="control-group">
                <h2>ç²’å­æ§åˆ¶</h2>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>ç²’å­æ•¸é‡</span>
                        <span id="particleCountValue">1500</span>
                    </div>
                    <input type="range" id="particleCountSlider" min="100" max="5000" value="1500" step="100">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>ç²’å­å¤§å°</span>
                        <span id="particleSizeValue">2.0</span>
                    </div>
                    <input type="range" id="particleSizeSlider" min="0.5" max="5" value="2.0" step="0.1">
                </div>
            </div>
            
            <div class="status">
                <div class="status-indicator" id="handStatusIndicator"></div>
                <span id="handStatusText">ç­‰å¾…æ‰‹éƒ¨åµæ¸¬...</span>
            </div>
            
            <div class="hand-status">
                æ‰‹å‹¢æ§åˆ¶: <span id="gestureText">æ¡æ‹³æ”¶ç¸® / å¼µé–‹æ“´å¼µ</span>
            </div>
            
            <div id="gestureInfo">
                <div>ğŸ‘Š <strong>æ¡æ‹³</strong>: ç²’å­æ”¶ç¸®èšé›†</div>
                <div>âœ‹ <strong>å¼µé–‹</strong>: ç²’å­æ“´æ•£å±•é–‹</div>
                <div>ğŸ‘† <strong>ç§»å‹•æ‰‹</strong>: æ§åˆ¶ç²’å­ä½ç½®</div>
            </div>
        </div>
        
        <div id="instructions">
            <div>è«‹å…è¨±ç€è¦½å™¨ä½¿ç”¨æ”å½±æ©Ÿæ¬Šé™ï¼Œä¸¦åœ¨é¡é ­å‰å±•ç¤ºæ‚¨çš„æ‰‹</div>
            <div class="particle-count">å³æ™‚ç²’å­æ•¸é‡: <span id="currentParticleCount">1500</span></div>
        </div>
    </div>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let scene, camera, renderer, particleSystem;
        let particles, particlePositions, particleColors;
        let handDetector;
        let isHandDetected = false;
        let lastHandPosition = { x: 0, y: 0, z: 0 };
        let currentShape = 'heart';
        let particleCount = 1500;
        let baseColor = new THREE.Color(0xFF7E5F);
        let particleSize = 2.0;
        let saturation = 1.0;
        
        // åˆå§‹åŒ– Three.js å ´æ™¯
        function initThreeJS() {
            // å‰µå»ºå ´æ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 10, 50);
            
            // å‰µå»ºç›¸æ©Ÿ
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 20);
            
            // å‰µå»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas3d'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // æ·»åŠ å…‰æº
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xff7e5f, 1, 100);
            pointLight.position.set(-5, 5, 5);
            scene.add(pointLight);
            
            // å‰µå»ºç²’å­ç³»çµ±
            createParticleSystem();
            
            // çª—å£å¤§å°èª¿æ•´äº‹ä»¶
            window.addEventListener('resize', onWindowResize);
        }
        
        // å‰µå»ºç²’å­ç³»çµ±
        function createParticleSystem() {
            // ç§»é™¤ç¾æœ‰çš„ç²’å­ç³»çµ±
            if (particleSystem) {
                scene.remove(particleSystem);
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
            }
            
            // å‰µå»ºç²’å­å¹¾ä½•é«”
            const geometry = new THREE.BufferGeometry();
            
            // åˆå§‹åŒ–ç²’å­ä½ç½®å’Œé¡è‰²
            particlePositions = new Float32Array(particleCount * 3);
            particleColors = new Float32Array(particleCount * 3);
            
            // è¨­ç½®åˆå§‹ç²’å­å½¢ç‹€
            updateParticleShape(currentShape);
            
            // è¨­ç½®ç²’å­é¡è‰²
            updateParticleColors();
            
            // è¨­ç½®å¹¾ä½•é«”å±¬æ€§
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            // å‰µå»ºç²’å­æè³ª
            const material = new THREE.PointsMaterial({
                size: particleSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            // å‰µå»ºç²’å­ç³»çµ±
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // æ›´æ–°é¡¯ç¤ºçš„ç²’å­æ•¸é‡
            document.getElementById('currentParticleCount').textContent = particleCount;
        }
        
        // æ›´æ–°ç²’å­å½¢ç‹€
        function updateParticleShape(shapeType) {
            currentShape = shapeType;
            
            // æ ¹æ“šå½¢ç‹€é¡å‹è¨­ç½®ç²’å­ä½ç½®
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                let x, y, z;
                
                // æ·»åŠ ä¸€äº›éš¨æ©Ÿåç§»
                const randomOffset = 0.1;
                
                switch(shapeType) {
                    case 'heart': // æ„›å¿ƒå½¢ç‹€
                        const t = (i / particleCount) * Math.PI * 2;
                        x = 8 * Math.pow(Math.sin(t), 3);
                        y = 6 * Math.cos(t) - 2 * Math.cos(2*t) - Math.cos(3*t) - Math.cos(4*t);
                        z = Math.sin(t * 3) * 2;
                        break;
                        
                    case 'flower': // èŠ±æœµå½¢ç‹€
                        const angle = (i / particleCount) * Math.PI * 10;
                        const radius = 5 + 2 * Math.sin(angle * 5);
                        x = radius * Math.cos(angle);
                        y = radius * Math.sin(angle);
                        z = Math.sin(angle * 3) * 3;
                        break;
                        
                    case 'saturn': // åœŸæ˜Ÿå½¢ç‹€
                        const ringAngle = (i / particleCount) * Math.PI * 2;
                        if (i % 3 === 0) { // è¡Œæ˜Ÿæœ¬é«”
                            const sphereAngle1 = Math.random() * Math.PI * 2;
                            const sphereAngle2 = Math.random() * Math.PI;
                            const sphereRadius = 4;
                            x = sphereRadius * Math.sin(sphereAngle2) * Math.cos(sphereAngle1);
                            y = sphereRadius * Math.sin(sphereAngle2) * Math.sin(sphereAngle1);
                            z = sphereRadius * Math.cos(sphereAngle2);
                        } else { // è¡Œæ˜Ÿç’°
                            const ringRadius = 6 + Math.sin(ringAngle * 5) * 0.5;
                            x = ringRadius * Math.cos(ringAngle);
                            y = ringRadius * Math.sin(ringAngle) * 0.3;
                            z = Math.cos(ringAngle * 8) * 0.5;
                        }
                        break;
                        
                    case 'firework': // ç…™ç«å½¢ç‹€
                        const angle2 = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        const radius2 = Math.random() * 8;
                        x = radius2 * Math.sin(phi) * Math.cos(angle2);
                        y = radius2 * Math.sin(phi) * Math.sin(angle2);
                        z = radius2 * Math.cos(phi);
                        break;
                        
                    case 'sphere': // çƒé«”å½¢ç‹€
                        const theta = Math.random() * Math.PI * 2;
                        const phi2 = Math.acos(2 * Math.random() - 1);
                        const radius3 = 6;
                        x = radius3 * Math.sin(phi2) * Math.cos(theta);
                        y = radius3 * Math.sin(phi2) * Math.sin(theta);
                        z = radius3 * Math.cos(phi2);
                        break;
                        
                    case 'cube': // ç«‹æ–¹é«”å½¢ç‹€
                        x = (Math.random() - 0.5) * 10;
                        y = (Math.random() - 0.5) * 10;
                        z = (Math.random() - 0.5) * 10;
                        break;
                        
                    case 'spiral': // èºæ—‹å½¢ç‹€
                        const spiralT = (i / particleCount) * Math.PI * 10;
                        const spiralRadius = 0.5 * spiralT;
                        x = spiralRadius * Math.cos(spiralT);
                        y = spiralRadius * Math.sin(spiralT);
                        z = spiralT - 15;
                        break;
                        
                    case 'wave': // æ³¢æµªå½¢ç‹€
                        const waveX = (i % 30) - 15;
                        const waveY = Math.floor(i / 30) - 15;
                        x = waveX;
                        y = waveY;
                        z = Math.sin(waveX * 0.3) * Math.cos(waveY * 0.3) * 4;
                        break;
                        
                    case 'random': // éš¨æ©Ÿå½¢ç‹€
                    default:
                        x = (Math.random() - 0.5) * 12;
                        y = (Math.random() - 0.5) * 12;
                        z = (Math.random() - 0.5) * 12;
                        break;
                }
                
                // æ·»åŠ éš¨æ©Ÿåç§»
                x += (Math.random() - 0.5) * randomOffset;
                y += (Math.random() - 0.5) * randomOffset;
                z += (Math.random() - 0.5) * randomOffset;
                
                // è¨­ç½®ç²’å­ä½ç½®
                particlePositions[i3] = x;
                particlePositions[i3 + 1] = y;
                particlePositions[i3 + 2] = z;
            }
            
            // æ›´æ–°å¹¾ä½•é«”
            if (particleSystem) {
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
            updateShapeButtons(shapeType);
        }
        
        // æ›´æ–°ç²’å­é¡è‰²
        function updateParticleColors() {
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // å‰µå»ºé¡è‰²è®ŠåŒ–
                let r, g, b;
                
                // æ ¹æ“šç²’å­ä½ç½®å‰µå»ºé¡è‰²æ¼¸è®Š
                const x = particlePositions[i3];
                const y = particlePositions[i3 + 1];
                const z = particlePositions[i3 + 2];
                
                // è¨ˆç®—è·é›¢ä¸­å¿ƒçš„è·é›¢
                const distance = Math.sqrt(x*x + y*y + z*z);
                const normalizedDistance = distance / 15;
                
                // åŸºç¤é¡è‰²
                r = baseColor.r;
                g = baseColor.g;
                b = baseColor.b;
                
                // æ ¹æ“šè·é›¢æ·»åŠ é¡è‰²è®ŠåŒ–
                const hueShift = normalizedDistance * 0.3;
                r = Math.min(1, r + hueShift);
                g = Math.min(1, g - hueShift * 0.5);
                b = Math.min(1, b + hueShift * 0.2);
                
                // æ‡‰ç”¨é£½å’Œåº¦
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                r = gray + (r - gray) * saturation;
                g = gray + (g - gray) * saturation;
                b = gray + (b - gray) * saturation;
                
                // ç¢ºä¿é¡è‰²å€¼åœ¨æœ‰æ•ˆç¯„åœå…§
                r = Math.max(0, Math.min(1, r));
                g = Math.max(0, Math.min(1, g));
                b = Math.max(0, Math.min(1, b));
                
                // è¨­ç½®ç²’å­é¡è‰²
                particleColors[i3] = r;
                particleColors[i3 + 1] = g;
                particleColors[i3 + 2] = b;
            }
            
            // æ›´æ–°å¹¾ä½•é«”
            if (particleSystem) {
                particleSystem.geometry.attributes.color.needsUpdate = true;
            }
        }
        
        // åˆå§‹åŒ– MediaPipe Hands
        async function initHandDetection() {
            const videoElement = document.getElementById('webcam');
            
            // å˜—è©¦ç²å–æ”å½±æ©Ÿæ¬Šé™
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 }
                });
                videoElement.srcObject = stream;
                
                // åˆå§‹åŒ– MediaPipe Hands
                handDetector = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                handDetector.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                handDetector.onResults(onHandResults);
                
                // é–‹å§‹æª¢æ¸¬
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await handDetector.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
                
                updateHandStatus(true, "æ‰‹éƒ¨åµæ¸¬å·²å•Ÿå‹•");
                
            } catch (error) {
                console.error('ç„¡æ³•è¨ªå•æ”å½±æ©Ÿ:', error);
                updateHandStatus(false, "ç„¡æ³•è¨ªå•æ”å½±æ©Ÿï¼Œè«‹æª¢æŸ¥æ¬Šé™");
                
                // å¦‚æœæ²’æœ‰æ”å½±æ©Ÿï¼Œä½¿ç”¨æ¨¡æ“¬æ‰‹å‹¢æ§åˆ¶
                setupSimulatedControls();
            }
        }
        
        // è™•ç†æ‰‹éƒ¨æª¢æ¸¬çµæœ
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                
                // ä½¿ç”¨ç¬¬ä¸€éš»æ‰‹çš„è³‡è¨Š
                const handLandmarks = results.multiHandLandmarks[0];
                
                // è¨ˆç®—æ‰‹éƒ¨ä¸­å¿ƒä½ç½®
                let sumX = 0, sumY = 0, sumZ = 0;
                for (const landmark of handLandmarks) {
                    sumX += landmark.x;
                    sumY += landmark.y;
                    sumZ += landmark.z;
                }
                
                const centerX = sumX / handLandmarks.length;
                const centerY = sumY / handLandmarks.length;
                const centerZ = sumZ / handLandmarks.length;
                
                // è¨ˆç®—æ‰‹éƒ¨å¼µé–‹ç¨‹åº¦ï¼ˆä½¿ç”¨é£ŸæŒ‡å’Œæ‹‡æŒ‡ä¹‹é–“çš„è·é›¢ï¼‰
                const thumbTip = handLandmarks[4]; // æ‹‡æŒ‡æŒ‡å°–
                const indexTip = handLandmarks[8]; // é£ŸæŒ‡æŒ‡å°–
                
                if (thumbTip && indexTip) {
                    const distance = Math.sqrt(
                        Math.pow(thumbTip.x - indexTip.x, 2) +
                        Math.pow(thumbTip.y - indexTip.y, 2) +
                        Math.pow(thumbTip.z - indexTip.z, 2)
                    );
                    
                    // æ ¹æ“šæ‰‹å‹¢æ§åˆ¶ç²’å­
                    updateParticlesWithHandGesture(centerX, centerY, centerZ, distance);
                    
                    // æ›´æ–°æ‰‹å‹¢æ–‡å­—
                    if (distance < 0.05) {
                        document.getElementById('gestureText').textContent = 'æ¡æ‹³ (æ”¶ç¸®)';
                    } else if (distance > 0.15) {
                        document.getElementById('gestureText').textContent = 'å¼µé–‹ (æ“´å¼µ)';
                    } else {
                        document.getElementById('gestureText').textContent = 'ä¸­é–“ç‹€æ…‹';
                    }
                }
                
                updateHandStatus(true, "æ‰‹éƒ¨å·²åµæ¸¬");
            } else {
                isHandDetected = false;
                updateHandStatus(false, "ç­‰å¾…æ‰‹éƒ¨å‡ºç¾...");
            }
        }
        
        // ä½¿ç”¨æ‰‹å‹¢æ›´æ–°ç²’å­
        function updateParticlesWithHandGesture(handX, handY, handZ, handOpenness) {
            // å°‡æ‰‹éƒ¨åº§æ¨™æ˜ å°„åˆ°3Dç©ºé–“
            const targetX = (handX - 0.5) * 30; // æ˜ å°„åˆ° -15 åˆ° 15 ç¯„åœ
            const targetY = (0.5 - handY) * 30; // åè½‰ Y è»¸
            const targetZ = (handZ - 0.5) * 20; // æ˜ å°„åˆ° -10 åˆ° 10 ç¯„åœ
            
            // å¹³æ»‘ç§»å‹•æ‰‹éƒ¨ä½ç½®
            lastHandPosition.x += (targetX - lastHandPosition.x) * 0.1;
            lastHandPosition.y += (targetY - lastHandPosition.y) * 0.1;
            lastHandPosition.z += (targetZ - lastHandPosition.z) * 0.1;
            
            // æ ¹æ“šæ‰‹éƒ¨å¼µé–‹ç¨‹åº¦æ§åˆ¶ç²’å­æ“´å¼µ/æ”¶ç¸®
            const expansionFactor = handOpenness * 3;
            
            // æ›´æ–°ç²’å­ä½ç½®
            const positions = particleSystem.geometry.attributes.position.array;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // ç²å–ç²’å­çš„åŸå§‹å½¢ç‹€ä½ç½®
                const originalX = particlePositions[i3];
                const originalY = particlePositions[i3 + 1];
                const originalZ = particlePositions[i3 + 2];
                
                // è¨ˆç®—ç²’å­ç›¸å°æ–¼æ‰‹éƒ¨çš„ä½ç½®
                const offsetX = originalX * (1 + expansionFactor * 0.5);
                const offsetY = originalY * (1 + expansionFactor * 0.5);
                const offsetZ = originalZ * (1 + expansionFactor * 0.5);
                
                // è¨­ç½®æœ€çµ‚ç²’å­ä½ç½®ï¼ˆè·Ÿéš¨æ‰‹éƒ¨ç§»å‹•ï¼‰
                positions[i3] = lastHandPosition.x + offsetX;
                positions[i3 + 1] = lastHandPosition.y + offsetY;
                positions[i3 + 2] = lastHandPosition.z + offsetZ;
            }
            
            // æ¨™è¨˜ä½ç½®éœ€è¦æ›´æ–°
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
        
        // è¨­ç½®æ¨¡æ“¬æ§åˆ¶ï¼ˆå¦‚æœæ²’æœ‰æ”å½±æ©Ÿï¼‰
        function setupSimulatedControls() {
            updateHandStatus(false, "ä½¿ç”¨æ»‘é¼ æ¨¡æ“¬æ§åˆ¶");
            
            let mouseX = 0, mouseY = 0;
            let isMouseDown = false;
            
            document.addEventListener('mousemove', (event) => {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });
            
            document.addEventListener('mousedown', () => {
                isMouseDown = true;
                document.getElementById('gestureText').textContent = 'æ¡æ‹³ (æ”¶ç¸®)';
            });
            
            document.addEventListener('mouseup', () => {
                isMouseDown = false;
                document.getElementById('gestureText').textContent = 'å¼µé–‹ (æ“´å¼µ)';
            });
            
            // åœ¨å‹•ç•«å¾ªç’°ä¸­æ›´æ–°æ¨¡æ“¬æ‰‹å‹¢
            function updateSimulatedGesture() {
                if (!isHandDetected) {
                    const targetX = mouseX * 15;
                    const targetY = mouseY * 15;
                    const targetZ = 0;
                    
                    lastHandPosition.x += (targetX - lastHandPosition.x) * 0.05;
                    lastHandPosition.y += (targetY - lastHandPosition.y) * 0.05;
                    lastHandPosition.z += (targetZ - lastHandPosition.z) * 0.05;
                    
                    const expansionFactor = isMouseDown ? 0.5 : 2.0;
                    
                    const positions = particleSystem.geometry.attributes.position.array;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        const originalX = particlePositions[i3];
                        const originalY = particlePositions[i3 + 1];
                        const originalZ = particlePositions[i3 + 2];
                        
                        const offsetX = originalX * expansionFactor;
                        const offsetY = originalY * expansionFactor;
                        const offsetZ = originalZ * expansionFactor;
                        
                        positions[i3] = lastHandPosition.x + offsetX;
                        positions[i3 + 1] = lastHandPosition.y + offsetY;
                        positions[i3 + 2] = lastHandPosition.z + offsetZ;
                    }
                    
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                }
                
                requestAnimationFrame(updateSimulatedGesture);
            }
            
            updateSimulatedGesture();
        }
        
        // æ›´æ–°æ‰‹éƒ¨ç‹€æ…‹é¡¯ç¤º
        function updateHandStatus(isActive, message) {
            const indicator = document.getElementById('handStatusIndicator');
            const statusText = document.getElementById('handStatusText');
            
            if (isActive) {
                indicator.className = 'status-indicator';
                indicator.style.background = '#4CAF50';
                indicator.style.boxShadow = '0 0 10px #4CAF50';
            } else {
                indicator.className = 'status-indicator inactive';
                indicator.style.background = '#f44336';
                indicator.style.boxShadow = '0 0 10px #f44336';
            }
            
            statusText.textContent = message;
        }
        
        // æ›´æ–°å½¢ç‹€æŒ‰éˆ•ç‹€æ…‹
        function updateShapeButtons(activeShape) {
            const shapeButtons = [
                'shapeHeart', 'shapeFlower', 'shapeSaturn', 
                'shapeFirework', 'shapeSphere', 'shapeCube',
                'shapeSpiral', 'shapeWave', 'shapeRandom'
            ];
            
            shapeButtons.forEach(buttonId => {
                const button = document.getElementById(buttonId);
                const shapeName = buttonId.replace('shape', '').toLowerCase();
                if (shapeName === activeShape) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }
        
        // çª—å£å¤§å°èª¿æ•´è™•ç†
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // å‹•ç•«å¾ªç’°
        function animate() {
            requestAnimationFrame(animate);
            
            // æ—‹è½‰ç²’å­ç³»çµ±
            if (particleSystem) {
                particleSystem.rotation.y += 0.002;
                particleSystem.rotation.x += 0.001;
            }
            
            // æ¸²æŸ“å ´æ™¯
            renderer.render(scene, camera);
        }
        
        // åˆå§‹åŒ– UI äº‹ä»¶
        function initUIEvents() {
            // å½¢ç‹€æŒ‰éˆ•äº‹ä»¶
            document.getElementById('shapeHeart').addEventListener('click', () => updateParticleShape('heart'));
            document.getElementById('shapeFlower').addEventListener('click', () => updateParticleShape('flower'));
            document.getElementById('shapeSaturn').addEventListener('click', () => updateParticleShape('saturn'));
            document.getElementById('shapeFirework').addEventListener('click', () => updateParticleShape('firework'));
            document.getElementById('shapeSphere').addEventListener('click', () => updateParticleShape('sphere'));
            document.getElementById('shapeCube').addEventListener('click', () => updateParticleShape('cube'));
            document.getElementById('shapeSpiral').addEventListener('click', () => updateParticleShape('spiral'));
            document.getElementById('shapeWave').addEventListener('click', () => updateParticleShape('wave'));
            document.getElementById('shapeRandom').addEventListener('click', () => updateParticleShape('random'));
            
            // é¡è‰²é¸æ“‡å™¨äº‹ä»¶
            document.getElementById('colorPicker').addEventListener('input', (event) => {
                baseColor = new THREE.Color(event.target.value);
                document.getElementById('colorValue').textContent = event.target.value.toUpperCase();
                updateParticleColors();
            });
            
            // é£½å’Œåº¦æ»‘æ¡¿äº‹ä»¶
            document.getElementById('saturationSlider').addEventListener('input', (event) => {
                saturation = event.target.value / 100;
                document.getElementById('saturationValue').textContent = event.target.value + '%';
                updateParticleColors();
            });
            
            // ç²’å­æ•¸é‡æ»‘æ¡¿äº‹ä»¶
            document.getElementById('particleCountSlider').addEventListener('input', (event) => {
                particleCount = parseInt(event.target.value);
                document.getElementById('particleCountValue').textContent = particleCount;
                createParticleSystem();
            });
            
            // ç²’å­å¤§å°æ»‘æ¡¿äº‹ä»¶
            document.getElementById('particleSizeSlider').addEventListener('input', (event) => {
                particleSize = parseFloat(event.target.value);
                document.getElementById('particleSizeValue').textContent = particleSize.toFixed(1);
                if (particleSystem) {
                    particleSystem.material.size = particleSize;
                }
            });
        }
        
        // åˆå§‹åŒ–æ‡‰ç”¨
        function init() {
            initThreeJS();
            initUIEvents();
            initHandDetection();
            animate();
        }
        
        // ç•¶é é¢åŠ è¼‰å®Œæˆæ™‚åˆå§‹åŒ–
        window.addEventListener('load', init);
    </script>
</body>
</html>